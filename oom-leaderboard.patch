diff --git a/app/(app)/(tabs)/leaderboard.tsx b/app/(app)/(tabs)/leaderboard.tsx
index 4738c9be..0dd7ba18 100644
--- a/app/(app)/(tabs)/leaderboard.tsx
+++ b/app/(app)/(tabs)/leaderboard.tsx
@@ -1,6 +1,7 @@
-import { useEffect, useState } from "react";
+import { useCallback, useEffect, useState } from "react";
 import { StyleSheet, View } from "react-native";
 import { Feather } from "@expo/vector-icons";
+import { useFocusEffect } from "@react-navigation/native";
 
 import { Screen } from "@/components/ui/Screen";
 import { AppText } from "@/components/ui/AppText";
@@ -8,112 +9,65 @@ import { AppCard } from "@/components/ui/AppCard";
 import { LoadingState } from "@/components/ui/LoadingState";
 import { EmptyState } from "@/components/ui/EmptyState";
 import { useBootstrap } from "@/lib/useBootstrap";
-import { getEventsBySocietyId, type EventDoc } from "@/lib/db_supabase/eventRepo";
 import { getMembersBySocietyId, type MemberDoc } from "@/lib/db_supabase/memberRepo";
+import { getOomLeaderboard } from "@/lib/db_supabase/oomRepo";
 import { getColors, spacing, radius } from "@/lib/ui/theme";
 
 type OOMEntry = {
   memberId: string;
   memberName: string;
   points: number;
-  wins: number;
-  eventsPlayed: number;
 };
 
 export default function LeaderboardScreen() {
   const { societyId, loading: bootstrapLoading } = useBootstrap();
   const colors = getColors();
 
-  const [events, setEvents] = useState<EventDoc[]>([]);
   const [members, setMembers] = useState<MemberDoc[]>([]);
+  const [standings, setStandings] = useState<OOMEntry[]>([]);
   const [loading, setLoading] = useState(true);
 
-  useEffect(() => {
-    const loadData = async () => {
-      if (!societyId) {
-        setLoading(false);
-        return;
-      }
-      setLoading(true);
-      try {
-        const [eventsData, membersData] = await Promise.all([
-          getEventsBySocietyId(societyId),
-          getMembersBySocietyId(societyId),
-        ]);
-        setEvents(eventsData);
-        setMembers(membersData);
-      } catch (err) {
-        console.error("Failed to load leaderboard data:", err);
-      } finally {
-        setLoading(false);
-      }
-    };
-
-    loadData();
-  }, [societyId]);
-
-  // Get relevant events for OOM: prefer isOOM events, fallback to all completed events
-  const getOOMEvents = (): EventDoc[] => {
-    const completedWithResults = events.filter((e) => e.isCompleted && e.results);
-
-    // Check if any events have isOOM explicitly set to true
-    const oomEvents = completedWithResults.filter((e) => e.isOOM === true);
-
-    // If we have OOM-flagged events, use only those; otherwise use all completed events
-    return oomEvents.length > 0 ? oomEvents : completedWithResults;
-  };
-
-  // Calculate OOM standings from completed OOM events
-  const calculateOOMStandings = (): OOMEntry[] => {
-    const relevantEvents = getOOMEvents();
-    const standings: Record<string, OOMEntry> = {};
-
-    // Initialize standings for all members
-    members.forEach((m) => {
-      standings[m.id] = {
-        memberId: m.id,
-        memberName: m.displayName || m.name || "Unknown",
-        points: 0,
-        wins: 0,
-        eventsPlayed: 0,
-      };
-    });
-
-    // Calculate points from each event
-    relevantEvents.forEach((event) => {
-      if (!event.results) return;
-
-      // Get sorted results for this event (by stableford or grossScore)
-      const eventResults = Object.entries(event.results)
-        .map(([memberId, result]) => ({
-          memberId,
-          score: result.stableford ?? result.netScore ?? result.grossScore ?? 0,
+  const loadData = useCallback(async () => {
+    if (!societyId) {
+      setLoading(false);
+      return;
+    }
+    setLoading(true);
+    try {
+      const [membersData, leaderboardData] = await Promise.all([
+        getMembersBySocietyId(societyId),
+        getOomLeaderboard(societyId),
+      ]);
+      const membersById = new Map(membersData.map((member) => [member.id, member]));
+      const enriched = leaderboardData
+        .map((entry) => ({
+          memberId: entry.member_id,
+          memberName:
+            membersById.get(entry.member_id)?.displayName
+            || membersById.get(entry.member_id)?.name
+            || "Unknown",
+          points: entry.total_points,
         }))
-        .sort((a, b) => b.score - a.score);
-
-      // Award points based on position (simple: 10 for 1st, 8 for 2nd, etc.)
-      const pointsTable = [10, 8, 6, 5, 4, 3, 2, 1];
-
-      eventResults.forEach((result, index) => {
-        if (standings[result.memberId]) {
-          standings[result.memberId].eventsPlayed++;
-          standings[result.memberId].points += pointsTable[index] ?? 1;
+        .filter((entry) => entry.points > 0)
+        .sort((a, b) => b.points - a.points);
+      setMembers(membersData);
+      setStandings(enriched);
+    } catch (err) {
+      console.error("Failed to load leaderboard data:", err);
+    } finally {
+      setLoading(false);
+    }
+  }, [societyId]);
 
-          if (index === 0) {
-            standings[result.memberId].wins++;
-          }
-        }
-      });
-    });
+  useEffect(() => {
+    loadData();
+  }, [loadData]);
 
-    // Sort by points, then wins
-    return Object.values(standings)
-      .filter((s) => s.eventsPlayed > 0)
-      .sort((a, b) => {
-        if (b.points !== a.points) return b.points - a.points;
-        return b.wins - a.wins;
-      });
-  };
+  useFocusEffect(
+    useCallback(() => {
+      loadData();
+    }, [loadData])
+  );
 
   if (bootstrapLoading || loading) {
     return (
@@ -125,18 +79,13 @@ export default function LeaderboardScreen() {
     );
   }
 
-  const relevantEvents = getOOMEvents();
-  const hasOOMFlaggedEvents = events.some((e) => e.isOOM === true);
-  const standings = calculateOOMStandings();
-
   return (
     <Screen>
       {/* Header */}
       <View style={styles.header}>
         <AppText variant="title">Order of Merit</AppText>
         <AppText variant="caption" color="secondary">
-          {relevantEvents.length} event{relevantEvents.length !== 1 ? "s" : ""} completed
-          {!hasOOMFlaggedEvents && relevantEvents.length > 0 ? " (all events)" : ""}
+          {standings.length} member{standings.length !== 1 ? "s" : ""} with points
         </AppText>
       </View>
 
@@ -144,7 +93,7 @@ export default function LeaderboardScreen() {
         <EmptyState
           icon={<Feather name="award" size={24} color={colors.textTertiary} />}
           title="No Order of Merit Points Yet"
-          message="Complete events with results to see the leaderboard. Mark events as 'Order of Merit' to track season standings separately."
+          message="Enter points for OOM events to see the leaderboard."
         />
       ) : (
         <View style={styles.list}>
@@ -182,18 +131,6 @@ export default function LeaderboardScreen() {
                   {/* Member Info */}
                   <View style={styles.memberInfo}>
                     <AppText variant="bodyBold">{entry.memberName}</AppText>
-                    <View style={styles.statsRow}>
-                      <AppText variant="caption" color="secondary">
-                        {entry.eventsPlayed} event{entry.eventsPlayed !== 1 ? "s" : ""}
-                      </AppText>
-                      {entry.wins > 0 && (
-                        <View style={[styles.winsBadge, { backgroundColor: colors.success + "20" }]}>
-                          <AppText variant="small" style={{ color: colors.success }}>
-                            {entry.wins} win{entry.wins !== 1 ? "s" : ""}
-                          </AppText>
-                        </View>
-                      )}
-                    </View>
                   </View>
 
                   {/* Points */}
@@ -213,7 +150,7 @@ export default function LeaderboardScreen() {
         <View style={styles.infoContent}>
           <Feather name="info" size={16} color={colors.textTertiary} />
           <AppText variant="caption" color="secondary" style={{ flex: 1 }}>
-            Points are awarded based on finishing position: 1st = 10pts, 2nd = 8pts, 3rd = 6pts, etc.
+            Points are summed from OOM events only.
           </AppText>
         </View>
       </AppCard>
@@ -252,17 +189,6 @@ const styles = StyleSheet.create({
   memberInfo: {
     flex: 1,
   },
-  statsRow: {
-    flexDirection: "row",
-    alignItems: "center",
-    gap: spacing.xs,
-    marginTop: 2,
-  },
-  winsBadge: {
-    paddingHorizontal: spacing.xs,
-    paddingVertical: 1,
-    borderRadius: radius.sm,
-  },
   pointsContainer: {
     alignItems: "center",
   },
diff --git a/lib/db_supabase/oomRepo.ts b/lib/db_supabase/oomRepo.ts
new file mode 100644
index 00000000..7f0ee0a5
--- /dev/null
+++ b/lib/db_supabase/oomRepo.ts
@@ -0,0 +1,55 @@
+import { supabase } from "@/lib/supabase";
+
+export type OomLeaderboardRow = {
+  member_id: string;
+  total_points: number;
+};
+
+export async function getOomLeaderboard(societyId: string): Promise<OomLeaderboardRow[]> {
+  const { data: eventsData, error: eventsError } = await supabase
+    .from("events")
+    .select("id")
+    .eq("society_id", societyId)
+    .or("classification.eq.oom,is_oom.eq.true");
+
+  if (eventsError) {
+    console.error("[oomRepo] getOomLeaderboard events failed:", {
+      message: eventsError.message,
+      details: eventsError.details,
+      hint: eventsError.hint,
+      code: eventsError.code,
+    });
+    return [];
+  }
+
+  const eventIds = (eventsData ?? []).map((event) => event.id).filter(Boolean);
+  if (eventIds.length === 0) {
+    return [];
+  }
+
+  const { data: resultsData, error: resultsError } = await supabase
+    .from("event_results")
+    .select("member_id,points")
+    .in("event_id", eventIds);
+
+  if (resultsError) {
+    console.error("[oomRepo] getOomLeaderboard results failed:", {
+      message: resultsError.message,
+      details: resultsError.details,
+      hint: resultsError.hint,
+      code: resultsError.code,
+    });
+    return [];
+  }
+
+  const totals = new Map<string, number>();
+  (resultsData ?? []).forEach((row) => {
+    const current = totals.get(row.member_id) ?? 0;
+    totals.set(row.member_id, current + (row.points ?? 0));
+  });
+
+  return Array.from(totals.entries()).map(([member_id, total_points]) => ({
+    member_id,
+    total_points,
+  }));
+}
